# 01. 객체, 설계

로버트 글래스(Rolert L. Glass)는 《소프트웨어 크리에이터비티 2.0》에서 '이론 대 실무'라는 주제에 대해 이론보다 실무가 먼저 발전한다고 주장합니다.
초기에는 실무를 통해 빠르게 발전이 이루어지고, 이후에야 실무의 경험을 바탕으로 이론이 정립된다고 설명합니다.
소프트웨어 분야는 역사적으로 짧아 아직 걸음마 단계에 머물러 있어 실무가 이론을 선도하고 있으며, 특히 소프트웨어 설계와 유지보수에서 그 격차가 두드러집니다.
훌륭한 소프트웨어 설계는 이론보다는 실제 코드를 통해 이루어지며, 유지보수에 관한 효과적인 이론은 아직 부족하다고 지적합니다.
글래스는 이론보다는 실무에 초점을 맞춘 접근이 소프트웨어 개발에 더 효과적이라고 결론짓습니다.
또한, 그의 책은 객체지향 프로그래밍의 원칙과 기법을 설명할 때 추상적인 이론보다는 구체적인 코드를 중심으로 다루어, 개발자가 실제 코드를 통해 더 잘 이해하고 활용할 수 있도록 돕고자 합니다.

## 1-2. 무엇이 문제인가

### 예상을 빗나가는 코드

`Theater` 클래스의 `enter` 메서드를 예로 들어, 코드가 예상과 다르게 동작할 때 발생하는 문제를 설명합니다.
실제 상황에서는 관람객이 직접 자신의 초대장을 판매원에게 건네고, 돈을 지불하며, 판매원이 티켓과 돈을 직접 관리합니다.
하지만 코드에서는 소극장이 관람객과 판매원의 행동을 대신 수행함으로써, 관람객과 판매원이 소극장의 통제 아래 수동적으로 동작하게 됩니다.
이러한 설계는 코드의 동작이 현실과 크게 벗어나 이해하기 어렵게 만들며, 읽는 사람이 코드를 직관적으로 이해하지 못하게 합니다.
또한, 여러 세부 사항을 동시에 기억해야 하기 때문에 코드의 가독성과 유지보수성이 저하됩니다.

### 변경에 취약한 코드

`Theater` 클래스가 `Audience`와 `Ticketseller`와의 높은 의존성을 가지고 있어 변경에 취약하다고 지적합니다.
예를 들어, 관람객이 가방을 사용하지 않거나, 판매원이 매표소 외부에서 티켓을 판매하게 되면 `Theater` 클래스도 함께 수정해야 합니다.
이러한 높은 결합도는 객체 간의 의존성이 강해져 하나의 변경이 여러 클래스에 영향을 미치게 만듭니다.
결과적으로, 소프트웨어의 유연성과 유지보수성이 떨어지게 됩니다.
객체지향 설계의 목표가 필수적인 의존성만 유지하고 불필요한 의존성을 제거하여 결합도를 낮추는 것임을 강조하며,
이를 통해 소프트웨어가 변경에 더 유연하게 대응할 수 있도록 해야 한다고 제안합니다.

## 1-3. 설계 개선하기

소프트웨어 모듈이 기능의 정확성, 변경의 용이성, 그리고 의사소통의 용이성이라는 세 가지 목적을 가져야 한다고 설명합니다. 
그러나 예제 코드는 기능은 제대로 수행하지만, `Theater` 클래스가 `Audience`의 `Bag`과 `Ticketseller`의 `Ticketoffice`에 직접 접근함으로써 높은 결합도가 형성되어 이해하기 어렵고 변경하기 쉬운 구조를 충족시키지 못합니다. 
이를 해결하기 위해 `Theater`가 `Audience`와 `Ticketseller`의 세부 사항을 알 필요가 없도록 정보를 은닉하고, `Theater`는 관람객의 입장만을 처리하며 `Audience`와 `Ticketseller`는 자신의 역할을 자율적으로 수행하도록 설계해야 합니다. 
이러한 접근은 객체 간의 결합도를 낮추고, 변경 시 영향을 최소화하여 코드의 이해도와 유지보수성을 향상시킵니다. 
결국, `Audience`와 `Ticketseller`를 자율적인 존재로 만들어 `Theater`와의 의존성을 줄이는 것이 중요함을 강조합니다.

### 자율성을 높이자

소프트웨어 모듈이 기능의 정확성, 변경의 용이성, 그리고 의사소통의 용이성이라는 세 가지 목적을 가져야 한다고 설명합니다. 
그러나 예제 코드는 기능은 제대로 수행하지만, `Theater` 클래스가 `Audience`의 `Bag`과 `Ticketseller`의 `Ticketoffice`에 직접 접근함으로써 높은 결합도가 형성되어 이해하기 어렵고 변경이 어려운 구조를 가지고 있습니다. 
이를 해결하기 위해 **자율성을 높이는 설계 변경**이 필요하며, 먼저 `Theater` 클래스의 `enter` 메서드에서 `Ticketoffice` 관련 코드를 `Ticketseller` 내부로 이동시키고 `sellTo` 메서드를 추가합니다. 
다음으로, `Ticketseller`가 `Audience`의 `Bag`에 직접 접근하는 대신 `Audience`에 `buy` 메서드를 추가하여 `Bag`의 세부 사항을 캡슐화합니다. 
이러한 설계 변경을 통해 `Theater`는 이제 `Ticketseller`의 인터페이스에만 의존하게 되고, `Audience`와 `Ticketseller`의 내부 구현에 대한 의존성이 사라져 객체 간의 결합도가 낮아지며, 각 객체는 자신의 역할을 자율적으로 수행하게 되어 코드의 이해도와 유지보수성이 크게 향상됩니다. 
결국, 캡슐화를 통해 객체 간의 의존성을 줄이고 자율성을 강화함으로써 소프트웨어 설계에서 변경에 유연하게 대응할 수 있는 구조를 만드는 것이 중요함을 강조합니다.

### 무엇이 개선됐는가

수정된 예제는 첫 번째 예제와 마찬가지로 관람객들을 입장시키는 기능을 오류 없이 수행하여 첫 번째 목적인 동작의 정확성을 만족시킵니다.
그렇다면 변경 용이성과 의사소통 측면은 어떨까요? 수정된 `Audience`와 `Ticketseller`는 자신들이 소유한 소지품을 스스로 관리함으로써 우리의 예상과 정확히 일치하게 동작합니다.
이는 코드를 읽는 사람과의 의사소통이 분명히 개선되었음을 의미합니다.
더욱 중요한 점은 `Audience`나 `Ticketseller`의 내부 구현을 변경하더라도 `Theater`를 함께 수정할 필요가 없다는 것입니다.
예를 들어, `Audience`가 가방 대신 작은 지갑을 소지하도록 변경하고 싶다면 `Audience` 내부만 수정하면 되고, `Ticketseller`가 매표소 대신 은행에 돈을 보관하도록 변경하고 싶다면 `Ticketseller` 내부만 수정하면 됩니다.
이러한 방식으로 변경이 `Audience`와 `Ticketseller` 내부에 국한되기 때문에 수정된 코드는 변경 용이성 측면에서도 확실히 개선되었습니다.

### 캡슐화와 응집도

소프트웨어 설계에서 캡슐화와 응집도의 중요성을 강조합니다.
캡슐화는 객체 내부의 상태를 감추고, 객체 간의 상호작용을 오직 메시지를 통해서만 이루어지도록 하는 것을 의미합니다.
예를 들어, `Theater` 클래스는 `Ticketseller`의 내부 구조를 알지 못하고, 단지 `sellTo` 메시지를 통해서만 상호작용합니다.
마찬가지로 `Ticketseller`도 `Audience`의 내부를 알지 못하고, `buy` 메시지를 통해서만 소통합니다.
이러한 설계는 객체들이 자신의 데이터를 자율적으로 관리하고 책임지도록 하여 결합도를 낮추고 응집도를 높입니다.
응집도가 높다는 것은 객체가 밀접하게 연관된 작업만을 수행하고, 관련 없는 작업은 다른 객체에 위임하는 것을 의미합니다.
이를 통해 객체 간의 의존성이 줄어들고, 변경이 필요할 때 특정 객체만 수정하면 되므로 유지보수성과 확장성이 향상됩니다.
결국, 캡슐화와 높은 응집도는 객체지향 설계에서 중요한 원칙으로, 시스템의 유연성과 견고성을 높이는 데 기여합니다.

### 절차지향과 객체지향

절차적 프로그래밍과 객체지향 프로그래밍의 차이를 설명합니다.
절차적 프로그래밍에서는 `Theater` 클래스가 `Audience`, `Ticketseller`, `Bag`, `Ticketoffice` 등 모든 데이터를 직접 관리하며 높은 결합도를 형성합니다. 
이는 코드 이해와 변경이 어렵게 만듭니다. 
반면 객체지향 프로그래밍에서는 각 객체가 자신의 데이터를 캡슐화하고 메시지를 통해 상호작용함으로써 결합도를 낮추고 응집도를 높입니다. 
예를 들어, `Theater`는 `Ticketseller`에만 의존하고, `Ticketseller`와 `Audience`는 자신의 내부를 관리합니다. 
이러한 설계는 코드의 이해도와 유지보수성을 향상시키며, 변경 시 영향 범위를 최소화합니다. 
객체지향 설계는 캡슐화를 통해 의존성을 적절히 관리하여 절차적 접근보다 더 유연하고 견고한 시스템을 구축할 수 있게 합니다.


### 책임의 의동

절차적 프로그래밍과 객체지향 프로그래밍의 근본적인 차이를 책임의 이동 개념을 통해 설명합니다.
절차적 방식에서는 `Theater` 클래스가 모든 데이터를 관리하며 높은 결합도로 인해 코드 이해와 변경이 어렵지만, 
객체지향 설계에서는 책임이 `Theater`, `Audience`, `Ticketseller` 등 각 객체로 분배되어 각 객체가 자신의 데이터를 자율적으로 관리합니다. 
이를 통해 캡슐화와 응집도가 높아져 결합도가 낮아지고, 변경 시 영향을 최소화하며 코드의 이해도와 유지보수성이 향상됩니다. 
객체지향 프로그래밍은 적절한 책임 할당과 객체 간의 최소한의 의존성을 유지함으로써 더 유연하고 견고한 설계를 가능하게 하며, 
이는 절차적 접근보다 더 효과적인 소프트웨어 개발 방식을 제공함을 강조합니다.


### 더 개선할 수 있다

현재의 설계는 이전보다 분명히 개선되었지만, 여전히 `Bag` 클래스가 수동적인 존재로 남아 있어 추가적인 개선이 필요합니다.
이를 해결하기 위해 `Bag`의 내부 로직을 캡슐화하고 자율적으로 관리하도록 변경하였으며, `Ticketseller`와 `Ticketoffice`의 책임도 적절히 분배하였습니다.
그러나 이러한 변경은 `Ticketoffice`와 `Audience` 간의 새로운 의존성을 초래하여 결합도가 상승하게 되었습니다.
개발팀은 결합도를 낮추는 것을 우선시하여 `Ticketoffice`의 자율성보다는 `Audience`와의 의존성을 줄이는 방향을 선택하였습니다
이 과정에서 설계는 여러 가지 트레이드오프의 결과물임을 깨닫게 되었으며, 훌륭한 설계는 이러한 균형을 맞추는 예술임을 다시 한번 확인할 수 있었습니다.
결국, 설계는 완벽할 수 없으며 항상 여러 요소들 간의 적절한 균형을 추구해야 함을 배우게 됩니다.

### 그래, 거짓말이다!

실생활에서 관람객과 판매자는 스스로 자신의 일을 처리하지만, 소프트웨어 객체지향 설계에서는 이들을 자율적이고 능동적인 존재로 다룹니다.
이를 의인화(anthropomorphism)라고 부르며, 이러한 설계 원칙은 코드의 이해와 유지보수를 용이하게 만듭니다. 
예를 들어, `Theater`, `Bag`, `Ticketoffice`와 같은 객체들은 실제로는 수동적이지만, 객체지향 세계에서는 스스로 책임을 지고 행동하는 자율적인 존재로 설계됩니다. 
이는 객체 간의 결합도를 낮추고 응집도를 높여 코드의 유연성과 견고성을 향상시키며, 변경 시 영향 범위를 최소화합니다. 
궁극적으로, 훌륭한 객체지향 설계는 모든 객체가 자율적으로 행동하도록 책임을 분배함으로써 더 이해하기 쉽고 변경하기 쉬운 코드를 만드는 데 중점을 둡니다.

## 1-4. 객체지향 설계

### 설계란 왜 필요한가

설계는 단순히 코드를 작성하는 행위를 넘어, 코드의 배치를 결정하는 창조적인 과정으로 구현과 밀접하게 연관되어 있습니다. 
예제 코드를 통해 절차적 설계와 객체지향 설계의 차이를 비교해보면, 좋은 설계는 현재 요구사항을 충족시키면서도 미래의 변경을 용이하게 수용할 수 있어야 합니다. 
이는 초기 개발 시 모든 요구사항을 완벽히 예측할 수 없고, 개발 과정에서 요구사항이 지속적으로 변하기 때문입니다. 
또한, 설계가 잘 되어 있지 않으면 코드 변경 시 버그가 발생할 가능성이 높아져 유지보수가 어려워집니다. 
따라서 설계는 코드의 유연성과 견고성을 보장하며, 변경에 대한 두려움을 줄이고 개발자의 생산성을 높이는 데 중요한 역할을 합니다. 
결국, 설계는 소프트웨어 개발에서 기능 구현과 미래의 확장을 모두 고려한 균형 잡힌 접근 방식을 가능하게 하여, 더 이해하기 쉽고 유지보수하기 용이한 코드를 작성할 수 있도록 돕습니다.


### 객체지향 설계

객체지향 프로그래밍(OOP)은 의존성을 효율적으로 관리함으로써 변경에 유연하게 대응할 수 있는 코드를 작성할 수 있게 해줍니다. 
이는 객체들이 자신의 데이터를 자율적으로 관리하고, 메시지를 통해 상호작용함으로써 코드의 이해도와 유지보수성을 높이는 데 기여합니다. 
좋은 객체지향 설계가 협력하는 객체들 간의 의존성을 적절히 조절하여 결합도를 낮추고 응집도를 높이는 것이라고 강조합니다. 
예제 코드에서는 `Theater`, `Audience`, `Ticketseller`, `Bag`, `Ticketoffice` 등의 객체들이 자율적으로 책임을 분담하며 협력하지만, 의존성이 과도하게 높아지면 변경이 어려워질 수 있습니다. 
따라서 훌륭한 객체지향 설계는 객체들이 자신의 역할을 명확히 수행하면서도 다른 객체와의 의존성을 최소화하여, 코드의 유연성과 견고성을 동시에 확보하는 균형 잡힌 접근 방식을 추구해야 합니다. 
이를 통해 소프트웨어는 더 이해하기 쉽고, 변경에 강하며, 유지보수가 용이한 구조로 발전할 수 있습니다.
