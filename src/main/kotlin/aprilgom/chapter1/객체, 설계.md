# 프로그래밍 패러다임
특정 시대의 어느 성숙한 개발자 공동체에 의해 수용된 프로그래밍 방법과 문제 해결방법, 스타일.
개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지한다.
프로그래밍 패러다임 교육으로 동일한 규칙과 방법을 공유하는 개발자로 성장시킨다.
각 프로그래밍 언어가 제공하는 특징과 스타일은 해당 언어가 채택하는 패러다임에 따라 달라진다.
절차지향 - C
객체지향 - JAVA
함수형 - LISP 등.
프로그래밍 패러다임은 서로 다른 패러다임이 하나의 언어 속에 공존함으로써 서로의 장단점을 보완하는 경향을 보인다.
다중 패러다임 언어 : 하나 이상의 패러다임을 수용하는 언어. 절차 + 객체인 C++과 함수 + 객체인 Scala.
프로그래밍 패러다임은 과거의 패러다임을 폐기시키기 보단 단점을 보완하는 것으로 보인다.
객체지향이 적합치 않은 상황에서 언제라도 다른 패러다임을 적용할 수 있는 시야를 기를것.

# 객체, 설계

이론은 유지보수에 별로 관심이 없다. 설계 분야에서 실무는 이론을 압도한다. 
설계를 설명함에 있어서 가장 유용한 도구는 코드 그 자체.

## 티켓 판매 어플리케이션 구현

## 문제점
### 예상을 빗나간 코드
Theater의 enter 메서드 - 극장이 관람객과 판매원의 지갑을 뒤지고 마음대로 돈과 티켓을 가져가고 넣는다? 극장 입장만 하고 싶을 뿐인데, 이런 문맥은 상식적이지 않다.

Audience와 TicketSeller가 Theater의 통제를 받는 매우 수동적인 존재 - Theater가 Audience와 TicketSeller의 내부 정보에 마음대로 접근하고 있음.
하나의 클래스나 메서드에서 너무 많은 세부사항을 다루기 때문에 읽는 사람에게 너무 큰 부담을 준다.

### 변경에 취약한 코드.
관람객이 가방을 가지고 다니지 않는다면? 신용카드를 사용한다면? Audience에서 Bag을 제거한다면 코드의 변경이 어떻게 이뤄질지 상상해보자. 

객체 사이의 의존성 문제로, 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다. 어플리케이션의 기능을 구현하는데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하자.

객체 사이의 의존성이 과한 경우를 가르켜 결합도가 높다고 말한다.

## 설계 개선하기.
관람객과 판매원이 자신의 일을 스스로 처리하도록 개선하자.

코드 변경
Theater가 TicketSeller의 인터페이스(interface)에만 의존한다.
TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 구현(implementation) 영역에 속한다.
객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.

코드 변경
Theater는 이제 Audience와 TicketSeller의 내부에 직접 접근하지 않는다.
이제 객체가 각자의 일을 스스로 처리하고 있다. 누군가에게 자신의 가방을 열어보도록 허용하지 않는다.

핵심은 객체 내부의 상태를 캡슐화하고 오직 메시지를 통해서만 상호작용하도록 만드는것.

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가르켜 응집도가 높다고 말한다. 응집도를 높이려면 객체 스스로 자신의 데이터를 책임져야 한다. 

### 절차지향과 객체지향

수정 전 코드는 각 객체에서 정보를 가져와 관람객을 입장시키는 절차를 구현했다. (Theater의 enter 메서드)

이 관점에서 enter메서드는 프로세스, Audience, Bag, TicketOffice는 데이터다. 이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라 부른다.

앞에서 살펴봤듯 절차적 프로그래밍은 우리의 직관에 위배된다. 여기에 더해 데이터 변경으로 인한 영향을 지역적으로 고립시키기 어렵다. 프로세스가 필요한 모든 데이터에 의존해야 한다.

Theater에서 Audience와 TicketSeller로 자신의 데이터를 스스로 처리하도록 프로세스를 이동시켰듯,
데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향이라 부른다.

훌륭한 객체지향의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는것이다.

### 책임의 이동
변경 전의 설계는 작업의 흐름이 주로 Theater에 집중되어 있었다. 책임이 Theater에 집중되어 있는 것.
변경 후의 설계는 작업의 흐름이 각 객체에 적절하게 분산되어 있다. 책임이 여러 객체에 분산되어 있는 것.

데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치하고 있다면, 절차적 프로그래밍 방식을 따르고 있을 가능성이 높다.

### 추가적인 개선
코드 변경

### 의인화
Audience와 TicketSeller가 스스로 자신을 책임져야 한다 서술했다.
Theater, Bag, TicketOffice는 실세계에서는 자율적인 존재가 아니다. 직관에 어긋나나,
객체지향의 세계에서는 모든 것이 능동적이고 자율적인 존재로 바뀐다. 이를 가르켜 의인화라 부른다.

객체지향에서는 모든 것을 능동적이고 자율적인 존재로 보고 설계한다.

## 객체지향 설계

### 설계가 왜 필요한가
설계란 코드를 배치하는 것. 우리가 변경하기 전의 코드와 변경한 후의 코드의 실행 결과는 같다. 하지만 배치가 다르다. 즉, 설계가 다르다.

좋은 설계란 무엇인가? 오늘 작동하는 동시에 내일 변경할 수 있는 코드.

변경을 수용할 수 있는 코드가 중요하다. 요구사항은 시시각각 바뀌기 때문.
요구사항 변경은 즉 코드 수정, 코드 수정은 버그 발생 가능성을 높인다. 버그의 가장 큰 문제점은 코드를 수정할 의지를 꺾는다. 코드 수정을 회피하려는 가장 큰 원인은 두려움이다. 요구사항 변경으로 인해 버그가 늘어날 것이라는 불확실성에서 나오는 두려움.

### 객체지향 설계
객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공함으로써 요구사항 변경에 좀 더 수월하게 대응할 수 있는 가능성을 높여준다. 

데이터와 프로세스를 단순히 뭉치는 것으로 좋은 설계가 나오는 것은 아니다. 어플리케이션의 기능은 객체들 간의 상호작용을 통해 구현되고, 상호작용은 객체 사이의 메시지로 표현된다.

객체 사이의 협력 과정 속에서 객체들은 다른 객체에 의존하게 된다. 메시지 전송을 위한 지식이 두 객체를 결합시키고 이 결합이 객체 사이의 의존성을 만든다.

훌륭한 객체지향 설계는 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다.
