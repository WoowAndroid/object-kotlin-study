# 01. 객체, 설계

## 1-1. 티켓 판매 애플리케이션 구현
리팩터링 이전 커밋 참고.

## 1-2. 무엇이 문제인가

> 로버트 마틴 - 클린 소프트웨어
> 
> 모듈이 만족해야 하는 세 가지 조건
> - 요구사항대로 동작할 것
> - 변경하기 쉬울 것
> - 이해하기 쉬울 것


### 예상을 빗나가는 코드
현재 코드에서 관람객과 판매원은 소극장의 통제를 받는 수동적 존재로,  
현실에서 관람객이 직접 가방에서 물건을 꺼내거나 판매원이 티켓을 판매한다는 상식을 벗어나게 동작한다.  
따라서 코드를 읽는 사람(개발자)과 제대로 의사소통하기 힘들다.  
하나의 클래스나 메서드에서 너무 많은 세부사항을 다루기에 개발자에게 부담을 준다.  
가령, `enter()` 메서드를 이해하기 위해선 다른 클래스들의 세부적인 내용들을 한꺼번에 알고 있어야 한다.

### 변경에 취약한 코드
현재 코드에서 `Theater`는 `Audience`와 `TicketSeller`의 세부적인 부분까지 알고 있다.  
만약 `Audience`와 `TicketSeller`의 내부 구조가 바뀐다면 이 클래스에 의존하는 `Theater`도 함께 변경될 것이다.

> `의존성(Dependency)`은 변경에 대한 영향을 암시한다.  
즉, 어떤 한 객체가 변경될 때 의존하고 있는 다른 객체도 함께 변경될 수 있다는 것이다.  
`결합도(Coupling)`는 의존성과 관련 있다.  
객체 사이의 의존성이 과한 경우 결합도가 높다, 합리적인 수준으로 의존할 경우 결합도가 낮다고 한다.  
결합도가 높을 경우 함께 변경될 가능성 또한 높아지며, 결합도가 낮을 수록 변경에 용이한 설계가 된다.

따라서 변경이 용이한 설계를 위해 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거함으로써 결합도를 낮추어야 한다.

## 1-3. 설계 개선하기

### 자율성을 높이자
`Theater`과의 결합도를 낮추기 위해 `Audience`과 `TicketSeller`을 자율적인 존재로 수정한다.

> `캡슐화(encapsulation)`는 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것이다.  
> 캡슐화로 객체 내부로의 접근을 제한 -> 객체 사이의 결합도를 낮춤 -> 변경에 용이

### 무엇이 개선됐는가

- 요구사항대로 동작할 것
- 변경하기 쉬울 것 : Audience와 TicketSeller의 변경이 해당 클래스 내부로 제한됨 (개선 완료)
- 이해하기 쉬울 것 : Audience와 TicketSeller가 자율적으로 행동함 (개선 완료)

### 어떻게 한 것인가

- [x] TicketSeller가 스스로 티켓을 판매하도록 수정
- Theater의 enter내 if문을 ticketSeller의 sellTo로 이동
- TicketOffice와 협력하는 TicketSeller의 내부 구현을 **캡슐화**


- [x] Audience가 스스로 티켓을 구매하도록 수정
- TicketSeller내 sellTo의 if문을 Audience의 buy로 이동
- Bag과 협력하는 Audience의 내부 구현을 **캡슐화**

### 캡슐화와 응집도
> 연관된 작업만 수행하고, 자신과 관련 없는 작업은 다른 객체에게 위임하는 객체를 `응집도(cohesion)`가 높다고 한다.  
> 객체의 응집도를 높이려면 자신의 데이터를 스스로 처리하는 자율적인 객체로 만들 것!

### 절차지향과 객체지향
> 프로세스(Process) : `enter()` 메서드  
> 데이터(Data) : `Audience`, `TicketSeller`, `Bag`, `TicketOffice`

- **절차 지향 프로그래밍(Procedural Programming)** : 프로세스와 데이터가 서로 다른 모듈(객체)에 위치  
- **객체 지향 프로그래밍(Object-Oriendted Programming)** : 프로세스와 데이터가 동일한 모듈(객체) 내부에 위치

### 책임의 이동
Theater에 몰려있던 책임을 분산
불필요한 의존성으로 객체 사이의 결합도가 높아 변경이 어려움 -> 결합도를 낮추기 위해 선택한 방법 : 캡슐화 -> 이를 통해 객체의 자율성과 응집도를 높임

### 더 개선할 수 있다

- [x] Bag이 스스로 티켓과 돈을 책임지도록 수정
- Audience내 buy의 if문을 Bag의 hold로 이동
- amount, invitation 상태와 관련 행위를 **캡슐화**

현재 구조에서는 `TicketSeller`가 `TicketOffice`의 `tickets`를 직접 꺼내어 `Audience`에게 팔고 있다.  
그렇다면 아래와 같은 의문이 든다.

1. Bag을 개선한 것처럼 `TicketOffice` 객체의 자율성도 높일 수 있지 않을까?
2. 이로서 `getTicket()` 메서드와 `plusAmount()` 메서드를 캡슐화 할 수 있지 않을까?

그러나 이러한 수정은 `TicketOffice`에 `Audience` 의존성을 추가한다!  

> 결국 설계는 트레이드오프의 산물이다.  
> **트레이드오프 시점** : `TicketOffice`의 자율성 ↔ 전체 설계 관점에서의 결합도

### 그래, 거짓말이다!
- 현실에서 **능동적인** 존재 : `TicketSeller`, `Audience`
- 현실에서 **수동적인** 존재 : `Bag`, `TicketOffice`

> 하지만 객체지향의 세계에서는 모든 존재가 능동적이고 자율적인 존재로 탈바꿈 한다!  
> 따라서 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계이다.


## 1-4. 객체지향 설계

### 설계가 왜 필요한가
우리는 요구사항의 기능을 구현하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야한다.  
요구사항은 항상 변경되며, 우리가 코드를 변경할 때 버그가 추가될 가능성이 높아진다.

### 객체지향 설계
앞의 예제를 통해 절차지향 설계보다 객체지향 설계가 코드 변경 측면에서 더 안정적이며,  
훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계임을 확인했다.
